<#
.SYNOPSIS
Redeploy the CustomScript extension for SirTunnel on an existing VM.

.DESCRIPTION
This script redeploys only the CustomScript extension—no changes to the VM, network, or disks.
It uses values from `config.ps1` and optionally persists tunnel metadata locally.
If tunnel files exist but cannot be persisted to your PowerShell profile, it prints a one-liner you can run.

.PARAMETER Force
Forces redeployment if extension is in a failed state.

.PARAMETER DryRun
Performs a dry run—no Azure operations, only local setup.

.EXAMPLE
.\redeploy-extension.ps1 -DryRun

.NOTES
Fails on unknown parameters. Requires AZ CLI and PowerShell 5+.
#>

[CmdletBinding()]
param(
  [switch]$Force,
  [switch]$DryRun
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Fail fast if unknown parameters were passed (e.g., --DryRun instead of -DryRun)
$allowedParams = 'Force', 'DryRun'
$rawArgs = $MyInvocation.Line.Split() | Where-Object { $_ -like '--*' -or $_ -like '-*' }
$invalidArgs = $rawArgs | Where-Object {
  ($_ -notmatch '^-(Force|DryRun)$') -and ($_ -notmatch '^--(Force|DryRun)$')
}
if ($invalidArgs) {
  throw "Unknown parameter(s): $($invalidArgs -join ', '). Use -Force or -DryRun (single dash only)."
}

# Load deployment config
Write-Host "[DEBUG] Loading config from: $PSScriptRoot/config.ps1" -ForegroundColor Cyan
. "$PSScriptRoot/config.ps1"
Write-Host "[DEBUG] Config loaded, VM_RG_NAME: $VM_RG_NAME" -ForegroundColor Cyan

# Build settings and protectedSettings objects
$settings = @{
  fileUris = @(
    "https://raw.githubusercontent.com/$GITHUB_REPO/main/scripts/install.sh",
    "https://raw.githubusercontent.com/$GITHUB_REPO/main/scripts/run_server.sh",
    "https://raw.githubusercontent.com/$GITHUB_REPO/main/scripts/caddy_config.json",
    "https://raw.githubusercontent.com/$GITHUB_REPO/main/scripts/sirtunnel.py"
  )
  skipDos2Unix = $false
}

$protected = @{
  commandToExecute = "bash install.sh $DNS_ZONE_RG $DNS_ZONE_NAME"
}

# Check current extension state
$existing = $null

if ($DryRun) {
  Write-Host "[DRY RUN] Skipping Azure operations. Will only set up local files." -ForegroundColor Yellow
} else {
  try {
    Write-Host "[INFO] Checking for existing extension..." -ForegroundColor Cyan
    $existingResult = az vm extension show `
      --resource-group $VM_RG_NAME `
      --vm-name $VM_NAME `
      --name customScript `
      --output json 2>&1

    if ($LASTEXITCODE -eq 0) {
      $existing = $existingResult | ConvertFrom-Json
      Write-Host "[INFO] Found existing extension with status: $($existing.provisioningState)" -ForegroundColor Cyan
    } else {
      Write-Host "[INFO] No existing extension found, will deploy new one" -ForegroundColor Cyan
    }
  } catch {
    Write-Host "[INFO] Error checking extension state, assuming it doesn't exist: $($_.Exception.Message)" -ForegroundColor Yellow
    $existing = $null
  }

  $status = if ($null -ne $existing) { $existing.provisioningState } else { $null }
  if ($status -eq 'Failed' -and -not $Force) {
    Write-Host "[WARN] Extension is in a failed state. Use -Force to delete and redeploy." -ForegroundColor Yellow
    $confirm = Read-Host "Delete and redeploy extension? (y/N)"
    if ($confirm -ne 'y') { exit 1 }
  }

  if ($null -ne $existing) {
    Write-Host "[INFO] Deleting existing extension before redeploy..." -ForegroundColor Cyan
    try {
      az vm extension delete `
        --resource-group $VM_RG_NAME `
        --vm-name $VM_NAME `
        --name customScript | Out-Null
      Write-Host "[INFO] Successfully deleted existing extension" -ForegroundColor Green
    } catch {
      Write-Host "[WARN] Failed to delete extension, but continuing with deployment: $($_.Exception.Message)" -ForegroundColor Yellow
    }
  }

  Write-Host "[INFO] Redeploying CustomScript extension..." -ForegroundColor Cyan
  $tempSettingsFile = [System.IO.Path]::GetTempFileName()
  $tempProtectedFile = [System.IO.Path]::GetTempFileName()

  try {
    ConvertTo-Json $settings -Depth 5 | Out-File $tempSettingsFile -Encoding UTF8
    ConvertTo-Json $protected -Depth 5 | Out-File $tempProtectedFile -Encoding UTF8

    az vm extension set `
      --name customScript `
      --publisher Microsoft.Azure.Extensions `
      --version 2.1 `
      --resource-group $VM_RG_NAME `
      --vm-name $VM_NAME `
      --force `
      --settings "@$tempSettingsFile" `
      --protected-settings "@$tempProtectedFile"
  } finally {
    if (Test-Path $tempSettingsFile) { Remove-Item $tempSettingsFile -Force }
    if (Test-Path $tempProtectedFile) { Remove-Item $tempProtectedFile -Force }
  }

  Write-Host "[INFO] Extension redeploy complete. Check /lib/waagent/custom-script/handler.log on the VM for logs."
}

# Import tunnel utilities if available
$utilsPath = Join-Path $PSScriptRoot "utils.ps1"
if (Test-Path $utilsPath) {
  . $utilsPath
} else {
  Write-Host "[WARN] Utils.ps1 not found. Tunnel state will not be persisted." -ForegroundColor Yellow
}

try {
  if ($DryRun) {
    $vmInfo = [PSCustomObject]@{ name = "VM_NAME_PLACEHOLDER"; publicIps = "10.20.30.40" }
    Write-Host "[DRY RUN] Using placeholder VM IP: $($vmInfo.publicIps)" -ForegroundColor Yellow
  } else {
    $vmInfo = az vm show --resource-group $VM_RG_NAME --name $VM_NAME --show-details --query "{name:name, publicIps:publicIps}" --output json | ConvertFrom-Json
  }

  if ($vmInfo -and $vmInfo.publicIps) {
    $tunDir = Initialize-TunnelEnvironment -SkipSecurePermissions:$DryRun
    $modulePath = Join-Path $PSScriptRoot "TunModule.psm1"

    if (Test-Path $utilsPath) {
      $tunnelInfo = if (Test-Path "$HOME/.tun/last.json") { Get-TunnelInfo -Silent } else { @{} }      $tunnelInfo = $tunnelInfo | Add-Member -NotePropertyName "vmIp" -NotePropertyValue $vmInfo.publicIps -Force -PassThru
      $tunnelInfo = $tunnelInfo | Add-Member -NotePropertyName "user" -NotePropertyValue $ADMIN_USER -Force -PassThru
      $tunnelInfo = $tunnelInfo | Add-Member -NotePropertyName "updated" -NotePropertyValue (Get-Date).ToString("o") -Force -PassThru
      
      # Pass the SkipSecurePermissions parameter when in DryRun mode
      Save-TunnelInfo -Info $tunnelInfo -SkipSecurePermissions:$DryRun
      
      $env:LAST_TUNNEL_VM = $vmInfo.publicIps
    }    # Copy module files with error handling    try {
      Copy-Item -Path $modulePath -Destination "$tunDir/TunModule.psm1" -Force
      Copy-Item -Path $utilsPath -Destination "$tunDir/utils.ps1" -Force
    } catch {
      Write-Warning "Could not copy module files: $($_.Exception.Message)"
    }# Create or update tunnel config
    try {
      $configPath = "$tunDir/config.json"
      $config = if (Test-Path $configPath) { Get-Content $configPath | ConvertFrom-Json } else { @{} }
      $config.Domain = "$DNS_ZONE_NAME"
      $config.AdminUser = "$ADMIN_USER"
      $config.LastVmIp = "$($vmInfo.publicIps)"
      $config | ConvertTo-Json | Set-Content $configPath
    } catch {
      Write-Warning "Could not update config file: $($_.Exception.Message)"
    }

    # Attempt to append import line to profile
    $importLine = "Import-Module `"$tunDir/TunModule.psm1`""
    $profilePath = $PROFILE
    $profileUpdated = $false

    try {
      if (-not (Test-Path $profilePath)) {
        New-Item -ItemType File -Path $profilePath -Force | Out-Null
      }

      $profileContent = ''
      $canRead = $false
      try {
        $profileContent = Get-Content $profilePath -Raw
        $canRead = $true
      } catch {
        Write-Warning "Profile exists but cannot be read: $($_.Exception.Message)"
      }

      if (-not $canRead -or ($profileContent -notmatch [regex]::Escape($importLine))) {
        try {
          Add-Content -Path $profilePath -Value "`n$importLine"
          $profileUpdated = $true
          Write-Host "[INFO] Import-Module line added to PowerShell profile." -ForegroundColor Green
        } catch {
          Write-Warning "Profile write failed: $($_.Exception.Message)"
        }
      } else {
        Write-Host "[INFO] Import line already present in PowerShell profile." -ForegroundColor Yellow
        $profileUpdated = $true
      }

    } catch {
      Write-Warning "Could not configure PowerShell profile: $($_.Exception.Message)"
    }

    # Summary and Manual Fallback if Needed
    if (-not $profileUpdated) {
      Write-Host "`n[MANUAL FIX REQUIRED]" -ForegroundColor Magenta
      Write-Host "To enable 'tun' in future sessions, run this command once:" -ForegroundColor Green
      Write-Host "`n  Add-Content -Path `"$PROFILE`" -Value 'Import-Module `"$tunDir/TunModule.psm1`"'" -ForegroundColor Yellow
    }

    Write-Host "`n[SUMMARY]" -ForegroundColor Cyan
    Write-Host "Tunnel module path: $tunDir" -ForegroundColor DarkCyan
    Write-Host "VM IP: $($vmInfo.publicIps)" -ForegroundColor Cyan
    Write-Host "`nTo use SirTunnel immediately, run:" -ForegroundColor Green
    Write-Host "  Import-Module `"$tunDir/TunModule.psm1`"" -ForegroundColor Yellow
    Write-Host "`nExample commands:" -ForegroundColor Green
    Write-Host "  tun api 3000           → https://api.tun.$DNS_ZONE_NAME" -ForegroundColor Cyan
    Write-Host "  tun dashboard 8080     → https://dashboard.tun.$DNS_ZONE_NAME" -ForegroundColor Cyan
  }
} catch {
  if ($_.Exception.Message -match "SeSecurityPrivilege") {
    Write-Warning "Could not set security permissions. Try running with admin privileges or use regular permissions instead."
    Write-Warning "Original error: $($_.Exception.Message)"
  } else {
    Write-Warning "Could not retrieve or configure tunnel alias: $($_.Exception.Message)"
  }
}
